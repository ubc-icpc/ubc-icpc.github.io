<!DOCTYPE html>
<html>
<head>
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shThemeDefault.css" rel="stylesheet" type="text/css" />
<link href="http://alexgorbatchev.com/pub/sh/current/styles/shCore.css" rel="stylesheet" type="text/css" />
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>
<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushCpp.js" type="text/javascript"></script>
<style type="text/css">.syntaxhighlighter{overflow-y: hidden !important; overflow-x: auto !important;}</style></head>
<body>
<pre class="brush: cpp">
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;utility&gt;
#include &lt;cstring&gt;

using namespace std;

int solve(int);
int times[20], dp[20];

int main(){
	int N; cin &gt;&gt; N;
	for(int i = 0; i &lt; N; i++){
		cin &gt;&gt; times[i];
	}
	sort(times, times+N);
	memset(dp, -1, sizeof dp);
	cout &lt;&lt; solve(N);	
	// queue&lt;pair&lt;map&lt;int, bool&gt;, long&gt; &gt; bfsq;
	// map&lt;int, bool&gt; initial;
	// for(int i = 0; i &lt; N; i++){
	// 	initial.insert(pair&lt;int, bool&gt;(i, true));
	// }

	// bfsq.push(make_pair(initial, 0));
	// long minTime = 10000000;

	// map&lt;int, int&gt; hashMap;
	// int sum = 0;
	// int maxx = 0;
	// for(int i = 0; i &lt; N; i++){
	// 	if(times[i] &gt; maxx) maxx = times[i];
	// 	sum += times[i];
	// }
	// sum -= maxx;
	// sum = sum*2;
	// while(!bfsq.empty()){
	// 	pair&lt;map&lt;int, bool&gt;, long&gt; curr = bfsq.front();
	// 	bfsq.pop();
	// 	map&lt;int, bool&gt; people; people = curr.first;
	// 	long currTime = curr.second;

	// 	int hash = 0;
	// 	for(int i = 0; i &lt; N; i++){
	// 		if(people.at(i)) hash += pow(2, i);
	// 	}

	// 	if(hashMap.count(hash) == 0){
	// 		hashMap.insert(make_pair(hash, currTime));
	// 	} else {
	// 		if(hashMap.at(hash) &gt;= currTime){
	// 			hashMap.at(hash) = currTime;
	// 		} else {
	// 			continue;
	// 		}
	// 	}

	// 	for(int i = 0; i &lt; N; i++){
	// 		for(int j = i+1; j &lt; N; j++){
	// 			map&lt;int, bool&gt; newPeople (people);
	// 			long newTime = currTime;
	// 			if(people.at(i) &amp;&amp; people.at(j)){

	// 				newPeople.at(i) = false; newPeople.at(j) = false;
	// 				newTime += max(times[i], times[j]);

	// 				int returner;
	// 				int returnTime = 1000000;
	// 				bool allArrived = true;
	// 				for(int k = 0; k &lt; N; k++){
	// 					if(!newPeople.at(k) &amp;&amp; times[k] &lt; returnTime){
	// 						returnTime = times[k];
	// 						returner = k;
	// 					} else if(newPeople.at(k)){
	// 						allArrived = false;
	// 					}
	// 				}
	// 				if(allArrived){
	// 					if(newTime &lt; minTime) minTime = newTime;
	// 					break;
	// 				} else {
	// 					newPeople.at(returner) = true;
	// 					newTime += returnTime;
	// 				}
	// 				if(newTime &gt; sum) continue;
	// 				// for(int k = 0; k &lt; N; k++){
	// 				// 	if(newPeople.at(k)){
	// 				// 		cout &lt;&lt; k &lt;&lt; &quot; &quot;;
	// 				// 	}
	// 				// }
	// 				// cout &lt;&lt; newTime &lt;&lt; endl;

	// 				bfsq.push(make_pair(newPeople, newTime));
	// 			}
	// 		}
	// 	}
	// }
	// cout &lt;&lt; minTime;
	// return 0;
}

int solve(int size){
	if(size == 1){
		return times[0];
	} else if(size == 2){
		return times[1];
	} else if(dp[size] != -1){
		return dp[size];
	}
	dp[size] = min(solve(size - 1) + times[0] + times[size - 1], solve(size - 2) + times[0] + 2*times[1] + times[size - 1]);
	return dp[size];
}</pre>
</body>
<script type="text/javascript">SyntaxHighlighter.all()</script></html>
